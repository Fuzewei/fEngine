// ---------------------------------------------------------------------
// THIS FILE IS AUTO-GENERATED BY BEHAVIAC DESIGNER, SO PLEASE DON'T MODIFY IT BY YOURSELF!
// ---------------------------------------------------------------------

#ifndef _BEHAVIAC_CUSTOMIZED_TYPES_H_
#define _BEHAVIAC_CUSTOMIZED_TYPES_H_

#include "behaviac/agent/agent.h"

// -------------------
// Customized structs
// -------------------

namespace behaviac
{
	struct EnemyInfo
	{
		int entityId;
		float dis;
	};
}

BEHAVIAC_EXTEND_EXISTING_TYPE_EX(behaviac::EnemyInfo, false);
BEHAVIAC_DECLARE_TYPE_VECTOR_HANDLER(behaviac::EnemyInfo);

template< typename SWAPPER >
inline void SwapByteImplement(behaviac::EnemyInfo& v)
{
	SwapByteImplement< SWAPPER >(v.entityId);
	SwapByteImplement< SWAPPER >(v.dis);
}

namespace behaviac
{
	namespace PrivateDetails
	{
		template<>
		inline bool Equal(const behaviac::EnemyInfo& lhs, const behaviac::EnemyInfo& rhs)
		{
			return Equal(lhs.entityId, rhs.entityId)
				&& Equal(lhs.dis, rhs.dis);
		}
	}
}

namespace behaviac
{
	struct Vector3
	{
		float x;
		float y;
		float z;
	};
}

BEHAVIAC_EXTEND_EXISTING_TYPE_EX(behaviac::Vector3, false);
BEHAVIAC_DECLARE_TYPE_VECTOR_HANDLER(behaviac::Vector3);

template< typename SWAPPER >
inline void SwapByteImplement(behaviac::Vector3& v)
{
	SwapByteImplement< SWAPPER >(v.x);
	SwapByteImplement< SWAPPER >(v.y);
	SwapByteImplement< SWAPPER >(v.z);
}

namespace behaviac
{
	namespace PrivateDetails
	{
		template<>
		inline bool Equal(const behaviac::Vector3& lhs, const behaviac::Vector3& rhs)
		{
			return Equal(lhs.x, rhs.x)
				&& Equal(lhs.y, rhs.y)
				&& Equal(lhs.z, rhs.z);
		}
	}
}

#endif // _BEHAVIAC_CUSTOMIZED_TYPES_H_
